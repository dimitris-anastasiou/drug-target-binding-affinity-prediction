{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "scrolled": true
   },
   "source": [
    "# **Drug-target binding affinity prediction for the PI3K Protein**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Name**: Anastasiou Dimitrios  \n",
    "**Father's Name**: Georgios  \n",
    "**R. Number**: 02117015  \n",
    "**Semester**: 7th  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Import Packages"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import sys\n",
    "    \n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.neighbors import KNeighborsClassifier\n",
    "from sklearn.tree import DecisionTreeClassifier\n",
    "from sklearn.metrics import accuracy_score, auc, average_precision_score, \\\n",
    "    confusion_matrix, pairwise_distances, precision_score, recall_score, roc_curve\n",
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "from rdkit import Chem\n",
    "from rdkit.Chem import DataStructs, Descriptors\n",
    "from rdkit.Chem.AllChem import GetMorganFingerprintAsBitVect\n",
    "from rdkit.Chem import Draw\n",
    "from rdkit.Chem import AllChem\n",
    "from rdkit.Chem.Draw import IPythonConsole"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Load Data\n",
    "\n",
    "First, we will use the pandas read_csv function to load the data.  \n",
    "> Data format:  \n",
    "    **biolab_index**: unique id, not used in this analysis.  \n",
    "    **rdkit**: string represantion of the compounds, generated by canonical smiles.  \n",
    "    **standard_value**: experimental measurment of binding affinity. Higher value stronger binding.  \n",
    "    **binary**: binary binding label, binding = 1, non-binding = 0. Calculated from standard value by using a 7 threshold.   \n",
    "    **assay_type**: experimental strategy, not used in this analysis.  \n",
    "    **not_sure**: Is the standard value between 6.5 - 7.5?  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>biolab_index</th>\n",
       "      <th>rdkit</th>\n",
       "      <th>standard_value</th>\n",
       "      <th>Binary</th>\n",
       "      <th>assay_type</th>\n",
       "      <th>not_sure</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>-2271189572612291214</td>\n",
       "      <td>CCc1ncnc(-c2ccc(C(=O)N3[C@H]4C[C@@H]3N4C)c(F)c...</td>\n",
       "      <td>6.477556</td>\n",
       "      <td>0</td>\n",
       "      <td>binding</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>-3586899716673204445</td>\n",
       "      <td>C[C@@H]1COCCN1c1nc(N2CCOC[C@H]2C)c2nc(-c3cc(CO...</td>\n",
       "      <td>6.769551</td>\n",
       "      <td>0</td>\n",
       "      <td>binding</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>8144662176983972856</td>\n",
       "      <td>COC[C@@]1(C(N)=O)CCCN1C(=O)Nc1nc(C)c(-c2ccnc(C...</td>\n",
       "      <td>7.309804</td>\n",
       "      <td>1</td>\n",
       "      <td>binding</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>2455001811534892714</td>\n",
       "      <td>CCN(CC)c1nccc(-c2sc(NC(=O)N3CC[C@@H]4C[C@]43C(...</td>\n",
       "      <td>7.119186</td>\n",
       "      <td>1</td>\n",
       "      <td>binding</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>-4774653679973179251</td>\n",
       "      <td>Cc1nc(NC(=O)N2CCC[C@]2(C(N)=O)C(F)F)sc1-c1ccnc...</td>\n",
       "      <td>6.886057</td>\n",
       "      <td>0</td>\n",
       "      <td>binding</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3749</th>\n",
       "      <td>4920656438462059447</td>\n",
       "      <td>C[C@@H]1Cc2ccccc2N1C(=O)Cc1nc(N2CCOCC2)cc(=O)[...</td>\n",
       "      <td>6.183264</td>\n",
       "      <td>0</td>\n",
       "      <td>binding</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3750</th>\n",
       "      <td>1468507578401046552</td>\n",
       "      <td>C[C@@H]1CCN(C(=O)Nc2nc3c(s2)-c2nc(C(C)(C)C)sc2...</td>\n",
       "      <td>7.961166</td>\n",
       "      <td>1</td>\n",
       "      <td>binding</td>\n",
       "      <td>0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3751</th>\n",
       "      <td>-2319550520878669600</td>\n",
       "      <td>Cc1nc(NC(=O)N2CCC[C@H]2C(N)=O)sc1-c1ccnc(C(C)(...</td>\n",
       "      <td>6.703167</td>\n",
       "      <td>0</td>\n",
       "      <td>binding</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3752</th>\n",
       "      <td>7071781108673184034</td>\n",
       "      <td>Cc1c(Cn2c(C)nn3c(=O)cc(N4CCOC(C)C4)nc23)cccc1C...</td>\n",
       "      <td>6.229557</td>\n",
       "      <td>0</td>\n",
       "      <td>binding</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3753</th>\n",
       "      <td>508010247029111850</td>\n",
       "      <td>Cc1nn2c(=O)cc(N3CCOC(C)C3)nc2n1Cc1cccc(Cl)c1Cl</td>\n",
       "      <td>6.032303</td>\n",
       "      <td>0</td>\n",
       "      <td>binding</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>3754 rows Ã— 6 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "             biolab_index                                              rdkit  \\\n",
       "0    -2271189572612291214  CCc1ncnc(-c2ccc(C(=O)N3[C@H]4C[C@@H]3N4C)c(F)c...   \n",
       "1    -3586899716673204445  C[C@@H]1COCCN1c1nc(N2CCOC[C@H]2C)c2nc(-c3cc(CO...   \n",
       "2     8144662176983972856  COC[C@@]1(C(N)=O)CCCN1C(=O)Nc1nc(C)c(-c2ccnc(C...   \n",
       "3     2455001811534892714  CCN(CC)c1nccc(-c2sc(NC(=O)N3CC[C@@H]4C[C@]43C(...   \n",
       "4    -4774653679973179251  Cc1nc(NC(=O)N2CCC[C@]2(C(N)=O)C(F)F)sc1-c1ccnc...   \n",
       "...                   ...                                                ...   \n",
       "3749  4920656438462059447  C[C@@H]1Cc2ccccc2N1C(=O)Cc1nc(N2CCOCC2)cc(=O)[...   \n",
       "3750  1468507578401046552  C[C@@H]1CCN(C(=O)Nc2nc3c(s2)-c2nc(C(C)(C)C)sc2...   \n",
       "3751 -2319550520878669600  Cc1nc(NC(=O)N2CCC[C@H]2C(N)=O)sc1-c1ccnc(C(C)(...   \n",
       "3752  7071781108673184034  Cc1c(Cn2c(C)nn3c(=O)cc(N4CCOC(C)C4)nc23)cccc1C...   \n",
       "3753   508010247029111850     Cc1nn2c(=O)cc(N3CCOC(C)C3)nc2n1Cc1cccc(Cl)c1Cl   \n",
       "\n",
       "      standard_value  Binary assay_type  not_sure  \n",
       "0           6.477556       0    binding         1  \n",
       "1           6.769551       0    binding         1  \n",
       "2           7.309804       1    binding         1  \n",
       "3           7.119186       1    binding         1  \n",
       "4           6.886057       0    binding         1  \n",
       "...              ...     ...        ...       ...  \n",
       "3749        6.183264       0    binding         1  \n",
       "3750        7.961166       1    binding         0  \n",
       "3751        6.703167       0    binding         1  \n",
       "3752        6.229557       0    binding         1  \n",
       "3753        6.032303       0    binding         1  \n",
       "\n",
       "[3754 rows x 6 columns]"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data_frame = pd.read_csv(\"drug_PI3K_data.csv\") \n",
    "data_frame"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can the plot a histogram of the label values, to check how many drugs are binders/not binders."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(array([2387.,    0.,    0.,    0.,    0.,    0.,    0.,    0.,    0.,\n",
       "        1367.]),\n",
       " array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ]),\n",
       " <BarContainer object of 10 artists>)"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.hist(data_frame.Binary)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 1: What is the % of drugs that have a positive label (bind to the PI3K protein)? What does this mean for the dataset and how will it affect the choice of evaluation metrics?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of positive labels: 1367\n",
      "Total labels' number(both positive and negative): 3754\n",
      "% of drugs that have a positive label: 36.41449120937666 %\n"
     ]
    }
   ],
   "source": [
    "Binary = data_frame.Binary\n",
    "x = len(Binary)\n",
    "j = 0\n",
    "for i in Binary:\n",
    "    if i == 1:\n",
    "        j = j + 1\n",
    "else:\n",
    "    print('Number of positive labels:', j)\n",
    "print(\"Total labels' number(both positive and negative):\", x)\n",
    "P = (j/x)*100\n",
    "print(\"% of drugs that have a positive label:\", P,\"%\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Judging from the percentage of the positive labels, we conclude that the dataset is strongly imbalanced since the % of drugs that have a positive label is 36.41449120937666 % < 50 %."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As a result, the choice of evaluation metrics will be affected because many of the standard metrics become unreliable or even misleading when classes are imbalanced. For example accuracy cannot be used for imbalanced datasets. Precision, however, is not affected by the large number of negative samples, thatâ€™s because it measures the number of true positives out of the samples predicted as positives (TP+FP). Consequently, with a large number of negative labels precision is probably better for specifying which model has better performance. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 2: Evaluate the performance of the following models in a stratified test set: KNN, logistic regression, decision tree, random forest (Use the ECFP4 features as input)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Extract compound features from SMILES format"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will use the rdkit library to convert SMILES strings to molecules first."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Transform rdkits to extended connectivity fingerprints\n",
    "rdkit = data_frame.rdkit\n",
    "# Use MolFromSmiles to identify molecules into the rdkits\n",
    "mols = [Chem.MolFromSmiles(smi) for smi in rdkit]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Visualize the first compound."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CCc1ncnc(-c2ccc(C(=O)N3[C@H]4C[C@@H]3N4C)c(F)c2)c1C#Cc1ccc(N)nc1\n"
     ]
    },
    {
     "data": {
      "image/png": "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04ipodmo+UpNTe3fv79QKJw3b56tra12r83S0lLteh5u681n/pI0bdq0V69eBw4cMESq3bt3jx071t3dPTs728rKqvYHcjNZe3v7zMzMWjaaqqU338SpU+jfH//5D2bPxoYNehwbAGbOnPnNN99YWlouXLhwyZIlXDcA0ohQhyczVVFRMWPGDMbY0qVLly5d+uIP19zQ+MKFC3Pnzj1x4kRRUZG+WjHVNGbMmM6dO2dkZHh6ejZr1kzbPYS7vKB9KRaLa75Uq9ULFiwAsHr1av3WUACxsQgKQlUVAOzfj2+/BZ+vh2ELCwsjIiIcHBzKysq4f6jUajVNaxolo86FidF89NFHADp16qSoe//R4cOHA/j4448NEYwxduHChaioqLr+TRYKhf3796/r7bJa2r6dJSYyT08GsB9/1MOAKSkpLi4uXPKOHTsuXLjwk08+ef3114uLi/UwOmlYdFJvji5cuNCrVy8ej3f27FluNWed/P777926dbO2ts7JyanNpdV6qKioKCgo+OvlBW1vkZovORs2bOjRowe3PF/vTpzAokXw98f27XjnHezdW/+hCgsLZ8+evX//fu07AoEgOzvb09NzwYIFUVFR2vJKGg1j13HS0BQKhZ+fH4CIiIh6D8JtVfThhx/qMdir7NdfWVIS69+fAczNje3bxyoq6jNOSkrKcy99RkdHM8a+++47esK/MaLZqNmJiYmJj4/38fFJS0vjVnPWQ0ZGRufOnS0tLXNycrjH+E3biRMoLoalJSZOhEIBADY2GDAAISEYObJWfa8LCgpmz579d/flTp06xTUEII2Sses4aVDp6emWlpZ8Pv/UqVM6DqXj3vSNy6+/spQUxhhzd2cAa92a8XgMYACzsWEjR7KUlHLukYbnSk5Ofu4ktFWrVp9++qlEImm4b0IMgMqoGVGpVFy7jfq1oXuGjnvTNy7JyWzxYpaTw3buZADr0YPdu8cSE9mwYUwo5DYU2MztpLJu3bqaT9QWFBS88847z1RPa2vrkJCQQ4cOKZVKI34poi9URs3IF198gactjfUyYL33pm90goIYwJKTWUUF8/Rk4eFMpXryR/n5bMMGNnXqEu1aL6FQOGjQoI0bNyYmJta8X8Tn8wMDAxMTE/X135+8IqiMmoubN29qWxrrcUyuFVNtVr43XsXFTChkVlaMO2uPi2M5OYwx9u23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\n",
      "text/plain": [
       "<rdkit.Chem.rdchem.Mol at 0x1cf7d42a6c0>"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(rdkit[0])\n",
    "mols[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then extract the binary features (fingerprints) for each molecule."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Get fingerprints from molecules in list format\n",
    "ECFP = [AllChem.GetMorganFingerprintAsBitVect(x,2,nBits=1024) for x in mols] # 1024 number of features\n",
    "\n",
    "# Change data format from list to numpy array\n",
    "a = np.array(ECFP)\n",
    "ECFP_data = a.astype(np.float32)\n",
    "\n",
    "# Create a numpy array with the binary labels for each molecule/compound\n",
    "Y_data = data_frame.Binary"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Visualize the feature vector of the first molecule/compound/drug."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 1., 1.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       1., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 1., 0., 1., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0.,\n",
       "       1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0.,\n",
       "       1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 1., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 1., 0.,\n",
       "       0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 1., 0., 1., 0., 0., 0., 0., 1., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 1., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 1., 0., 0., 0., 0.,\n",
       "       1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0.,\n",
       "       0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n",
       "       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,\n",
       "       0., 0., 0., 0.], dtype=float32)"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.set_printoptions(threshold=sys.maxsize)\n",
    "ECFP_data[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Split data to train and test"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will use sklearn's function train_test_split to split the compounds into training and test.  \n",
    "By using the stratified version, the function splits the data by keeping the same label distribution in training and test sets."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "X_train, X_test, y_train, y_test = train_test_split(ECFP_data, Y_data, stratify = Y_data, test_size = 0.2, random_state = 56)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "What is the shape of X and y arrays."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3003, 1024) (751, 1024)\n",
      "(3003,) (751,)\n"
     ]
    }
   ],
   "source": [
    "print(X_train.shape, X_test.shape)\n",
    "\n",
    "print(y_train.shape, y_test.shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we can see, the label distribution is the same in the training and test set."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(array([1909.,    0.,    0.,    0.,    0.,    0.,    0.,    0.,    0.,\n",
       "        1094.]),\n",
       " array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ]),\n",
       " <BarContainer object of 10 artists>)"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAX0AAAD8CAYAAACb4nSYAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjMuMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/Il7ecAAAACXBIWXMAAAsTAAALEwEAmpwYAAATPklEQVR4nO3df6zd9X3f8edrkCC6hIXUF+T6x+xEJq1BjVPuGFqWiI5tOLSqydRsZlNgGZITRqZE6x+BTFqiTZbI1jQT6iByEgRIKdQtSfFUaEtZFzYVQq9TB9sQN5cfhRtb2AlTw5rKm817f5yv11Nzr+/xOece7/rzfEhH53ve38/3+/18ZOvlrz/ne77fVBWSpDb8tTPdAUnS5Bj6ktQQQ1+SGmLoS1JDDH1JaoihL0kNWTT0k6xJ8gdJnk2yP8knuvrbkzya5Lvd+4V929yWZDbJgSTX9NUvT7K3W3dHkizNsCRJ8xnkTP8Y8EtV9VPAlcAtSTYCtwKPVdUG4LHuM926rcClwGbgziTndPu6C9gGbOhem8c4FknSIhYN/ao6VFXf6pZfA54FVgFbgHu7ZvcC13XLW4AHqupoVb0AzAJXJFkJXFBVT1TvF2H39W0jSZqAc0+ncZJ1wHuAbwIXV9Uh6P3DkOSirtkq4Mm+zea62v/plk+un9KKFStq3bp1p9NNSWre7t27v19VUyfXBw79JG8BHgQ+WVU/PMV0/Hwr6hT1+Y61jd40EGvXrmVmZmbQbkqSgCR/Ol99oKt3kryJXuB/taq+1pVf6aZs6N4Pd/U5YE3f5quBg1199Tz1N6iqHVU1XVXTU1Nv+IdKkjSkQa7eCfAV4Nmq+pW+VbuAG7vlG4GH+upbk5yXZD29L2yf6qaCXktyZbfPG/q2kSRNwCDTO+8FPgzsTbKnq30auB3YmeQm4CXgQwBVtT/JTuAZelf+3FJVx7vtbgbuAc4HHulekqQJyf/vt1aenp4u5/Ql6fQk2V1V0yfX/UWuJDXE0Jekhhj6ktQQQ1+SGmLoS1JDTus2DMvNult/+4wc98Xbf+6MHFeSFuOZviQ1xNCXpIYY+pLUEENfkhpi6EtSQwx9SWqIoS9JDTH0Jakhhr4kNcTQl6SGGPqS1BBDX5IaMsiD0e9OcjjJvr7aryfZ071ePPHs3CTrkvxF37ov9m1zeZK9SWaT3NE9HF2SNEGD3GXzHuBXgftOFKrqn5xYTvJ54M/62j9XVZvm2c9dwDbgSeBhYDM+GF2SJmrRM/2qehx4db513dn6PwbuP9U+kqwELqiqJ6r3JPb7gOtOu7eSpJGMOqf/PuCVqvpuX219kj9O8o0k7+tqq4C5vjZzXU2SNEGjPkTlev7qWf4hYG1V/SDJ5cBvJbkUmG/+vhbaaZJt9KaCWLt27YhdlCSdMPSZfpJzgX8E/PqJWlUdraofdMu7geeAS+id2a/u23w1cHChfVfVjqqarqrpqampYbsoSTrJKNM7fx/4TlX9v2mbJFNJzumW3wFsAJ6vqkPAa0mu7L4HuAF4aIRjS5KGMMglm/cDTwDvSjKX5KZu1Vbe+AXu+4Gnk3wb+E3gY1V14kvgm4EvA7P0/gfglTuSNGGLzulX1fUL1P/5PLUHgQcXaD8DXHaa/ZMkjZG/yJWkhhj6ktQQQ1+SGmLoS1JDDH1JaoihL0kNMfQlqSGGviQ1xNCXpIYY+pLUEENfkhpi6EtSQwx9SWqIoS9JDTH0Jakhhr4kNcTQl6SGGPqS1JBBnpF7d5LDSfb11T6b5HtJ9nSva/vW3ZZkNsmBJNf01S9Psrdbd0f3gHRJ0gQNcqZ/D7B5nvoXqmpT93oYIMlGeg9Mv7Tb5s4k53Tt7wK2ARu613z7lCQtoUVDv6oeB14dcH9bgAeq6mhVvQDMAlckWQlcUFVPVFUB9wHXDdlnSdKQRpnT/3iSp7vpnwu72irg5b42c11tVbd8cl2SNEHDhv5dwDuBTcAh4PNdfb55+jpFfV5JtiWZSTJz5MiRIbsoSTrZUKFfVa9U1fGqeh34EnBFt2oOWNPXdDVwsKuvnqe+0P53VNV0VU1PTU0N00VJ0jyGCv1ujv6EDwInruzZBWxNcl6S9fS+sH2qqg4BryW5srtq5wbgoRH6LUkawrmLNUhyP3AVsCLJHPAZ4Kokm+hN0bwIfBSgqvYn2Qk8AxwDbqmq492ubqZ3JdD5wCPdS5I0QYuGflVdP0/5K6dovx3YPk99BrjstHonSRorf5ErSQ0x9CWpIYa+JDXE0Jekhhj6ktQQQ1+SGmLoS1JDDH1JaoihL0kNMfQlqSGGviQ1xNCXpIYY+pLUEENfkhpi6EtSQwx9SWqIoS9JDTH0Jakhhr4kNWTR0E9yd5LDSfb11f5jku8keTrJ15O8rauvS/IXSfZ0ry/2bXN5kr1JZpPckSRLMiJJ0oIGOdO/B9h8Uu1R4LKq+mngT4Db+tY9V1WbutfH+up3AduADd3r5H1KkpbYoqFfVY8Dr55U+72qOtZ9fBJYfap9JFkJXFBVT1RVAfcB1w3VY0nS0MYxp/8vgEf6Pq9P8sdJvpHkfV1tFTDX12auq80rybYkM0lmjhw5MoYuSpJgxNBP8m+AY8BXu9IhYG1VvQf418CvJbkAmG/+vhbab1XtqKrpqpqempoapYuSpD7nDrthkhuBnweu7qZsqKqjwNFueXeS54BL6J3Z908BrQYODntsSdJwhjrTT7IZ+BTwC1X1o776VJJzuuV30PvC9vmqOgS8luTK7qqdG4CHRu69JOm0LHqmn+R+4CpgRZI54DP0rtY5D3i0u/Lyye5KnfcD/y7JMeA48LGqOvEl8M30rgQ6n953AP3fA0iSJmDR0K+q6+cpf2WBtg8CDy6wbga47LR6J0kaK3+RK0kNMfQlqSGGviQ1xNCXpIYY+pLUEENfkhpi6EtSQwx9SWqIoS9JDTH0Jakhhr4kNWToWytLUgvW3frbZ+S4L97+c0uyX8/0Jakhhr4kNcTQl6SGGPqS1BBDX5IaYuhLUkMWDf0kdyc5nGRfX+3tSR5N8t3u/cK+dbclmU1yIMk1ffXLk+zt1t3RPSBdkjRBg5zp3wNsPql2K/BYVW0AHus+k2QjsBW4tNvmziTndNvcBWwDNnSvk/cpSVpii4Z+VT0OvHpSeQtwb7d8L3BdX/2BqjpaVS8As8AVSVYCF1TVE1VVwH1920iSJmTYOf2Lq+oQQPd+UVdfBbzc126uq63qlk+uzyvJtiQzSWaOHDkyZBclSScb9xe5883T1ynq86qqHVU1XVXTU1NTY+ucJLVu2NB/pZuyoXs/3NXngDV97VYDB7v66nnqkqQJGjb0dwE3dss3Ag/11bcmOS/Jenpf2D7VTQG9luTK7qqdG/q2kSRNyKJ32UxyP3AVsCLJHPAZ4HZgZ5KbgJeADwFU1f4kO4FngGPALVV1vNvVzfSuBDofeKR7SZImaNHQr6rrF1h19QLttwPb56nPAJedVu8kSWPlL3IlqSGGviQ1xNCXpIYY+pLUEENfkhpi6EtSQwx9SWqIoS9JDTH0Jakhhr4kNcTQl6SGGPqS1BBDX5IaYuhLUkMMfUlqiKEvSQ0x9CWpIYa+JDVk6NBP8q4ke/peP0zyySSfTfK9vvq1fdvclmQ2yYEk14xnCJKkQS36jNyFVNUBYBNAknOA7wFfBz4CfKGqfrm/fZKNwFbgUuAngN9Pcknfg9MlSUtsXNM7VwPPVdWfnqLNFuCBqjpaVS8As8AVYzq+JGkA4wr9rcD9fZ8/nuTpJHcnubCrrQJe7msz19XeIMm2JDNJZo4cOTKmLkqSRg79JG8GfgH4ja50F/BOelM/h4DPn2g6z+Y13z6rakdVTVfV9NTU1KhdlCR1xnGm/wHgW1X1CkBVvVJVx6vqdeBL/OUUzhywpm+71cDBMRxfkjSgcYT+9fRN7SRZ2bfug8C+bnkXsDXJeUnWAxuAp8ZwfEnSgIa+egcgyY8B/wD4aF/5PyTZRG/q5sUT66pqf5KdwDPAMeAWr9yRpMkaKfSr6kfAj59U+/Ap2m8Hto9yTEnS8PxFriQ1xNCXpIYY+pLUEENfkhpi6EtSQwx9SWqIoS9JDTH0Jakhhr4kNcTQl6SGGPqS1BBDX5IaYuhLUkMMfUlqiKEvSQ0x9CWpIYa+JDXE0JekhowU+kleTLI3yZ4kM13t7UkeTfLd7v3Cvva3JZlNciDJNaN2XpJ0esZxpv+zVbWpqqa7z7cCj1XVBuCx7jNJNgJbgUuBzcCdSc4Zw/ElSQNaiumdLcC93fK9wHV99Qeq6mhVvQDMAlcswfElSQsYNfQL+L0ku5Ns62oXV9UhgO79oq6+Cni5b9u5riZJmpBzR9z+vVV1MMlFwKNJvnOKtpmnVvM27P0Dsg1g7dq1I3ZRknTCSGf6VXWwez8MfJ3edM0rSVYCdO+Hu+ZzwJq+zVcDBxfY746qmq6q6ampqVG6KEnqM3ToJ/nrSd56Yhn4h8A+YBdwY9fsRuChbnkXsDXJeUnWAxuAp4Y9viTp9I0yvXMx8PUkJ/bza1X1O0n+CNiZ5CbgJeBDAFW1P8lO4BngGHBLVR0fqfeSpNMydOhX1fPAu+ep/wC4eoFttgPbhz2mJGk0/iJXkhpi6EtSQwx9SWqIoS9JDTH0Jakhhr4kNcTQl6SGGPqS1BBDX5IaYuhLUkMMfUlqiKEvSQ0x9CWpIYa+JDXE0Jekhhj6ktQQQ1+SGmLoS1JDRnkw+pokf5Dk2ST7k3yiq382yfeS7Ole1/Ztc1uS2SQHklwzjgFIkgY3yoPRjwG/VFXfSvJWYHeSR7t1X6iqX+5vnGQjsBW4FPgJ4PeTXOLD0SVpcoY+06+qQ1X1rW75NeBZYNUpNtkCPFBVR6vqBWAWuGLY40uSTt9Y5vSTrAPeA3yzK308ydNJ7k5yYVdbBbzct9kcp/5HQpI0ZiOHfpK3AA8Cn6yqHwJ3Ae8ENgGHgM+faDrP5rXAPrclmUkyc+TIkVG7KEnqjBT6Sd5EL/C/WlVfA6iqV6rqeFW9DnyJv5zCmQPW9G2+Gjg4336rakdVTVfV9NTU1ChdlCT1GeXqnQBfAZ6tql/pq6/sa/ZBYF+3vAvYmuS8JOuBDcBTwx5fknT6Rrl6573Ah4G9SfZ0tU8D1yfZRG/q5kXgowBVtT/JTuAZelf+3OKVO5I0WUOHflX9D+afp3/4FNtsB7YPe0xJ0mj8Ra4kNcTQl6SGGPqS1BBDX5IaYuhLUkMMfUlqiKEvSQ0x9CWpIYa+JDXE0Jekhhj6ktQQQ1+SGmLoS1JDDH1JaoihL0kNMfQlqSGGviQ1xNCXpIZMPPSTbE5yIMlsklsnfXxJatlEQz/JOcB/Bj4AbKT3EPWNk+yDJLVs0mf6VwCzVfV8Vf1v4AFgy4T7IEnNmnTorwJe7vs819UkSRNw7oSPl3lq9YZGyTZgW/fxfyU5MOTxVgDfH3LboeVzkz7iX3FGxnyGOeazX2vjJZ8becx/c77ipEN/DljT93k1cPDkRlW1A9gx6sGSzFTV9Kj7WU4ccxtaG3Nr44WlG/Okp3f+CNiQZH2SNwNbgV0T7oMkNWuiZ/pVdSzJx4HfBc4B7q6q/ZPsgyS1bNLTO1TVw8DDEzrcyFNEy5BjbkNrY25tvLBEY07VG75HlSSdpbwNgyQ15KwI/cVu7ZCeO7r1Tyf5mTPRz3EZYLz/rBvn00n+MMm7z0Q/x2nQ23ck+VtJjif5xUn2bykMMuYkVyXZk2R/km9Muo/jNsDf7b+R5L8k+XY35o+ciX6OS5K7kxxOsm+B9ePPrqpa1i96Xwg/B7wDeDPwbWDjSW2uBR6h9zuBK4Fvnul+L/F4/w5wYbf8geU83kHH3Nfuv9L7zugXz3S/J/Dn/DbgGWBt9/miM93vCYz508DnuuUp4FXgzWe67yOM+f3AzwD7Flg/9uw6G870B7m1wxbgvup5EnhbkpWT7uiYLDreqvrDqvqf3ccn6f0eYjkb9PYd/wp4EDg8yc4tkUHG/E+Br1XVSwBVtdzHPciYC3hrkgBvoRf6xybbzfGpqsfpjWEhY8+usyH0B7m1w9l0+4fTHctN9M4UlrNFx5xkFfBB4IsT7NdSGuTP+RLgwiT/LcnuJDdMrHdLY5Ax/yrwU/R+1LkX+ERVvT6Z7p0RY8+uiV+yuQQGubXDQLd/WCYGHkuSn6UX+n93SXu09AYZ838CPlVVx3sngcveIGM+F7gcuBo4H3giyZNV9SdL3bklMsiYrwH2AH8PeCfwaJL/XlU/XOK+nSljz66zIfQHubXDQLd/WCYGGkuSnwa+DHygqn4wob4tlUHGPA080AX+CuDaJMeq6rcm0sPxG/Tv9fer6s+BP0/yOPBuYLmG/iBj/ghwe/UmvGeTvAD8JPDUZLo4cWPPrrNhemeQWzvsAm7ovgm/Evizqjo06Y6OyaLjTbIW+Brw4WV81tdv0TFX1fqqWldV64DfBP7lMg58GOzv9UPA+5Kcm+THgL8NPDvhfo7TIGN+id7/bEhyMfAu4PmJ9nKyxp5dy/5Mvxa4tUOSj3Xrv0jvao5rgVngR/TOFpalAcf7b4EfB+7sznyP1TK+WdWAYz6rDDLmqno2ye8ATwOvA1+uqnkv/VsOBvxz/vfAPUn20pv6+FRVLdu7bya5H7gKWJFkDvgM8CZYuuzyF7mS1JCzYXpHkjQgQ1+SGmLoS1JDDH1JaoihL0kNMfQlqSGGviQ1xNCXpIb8Xz1QqWV80X2/AAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.hist(y_train)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(array([478.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 273.]),\n",
       " array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ]),\n",
       " <BarContainer object of 10 artists>)"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.hist(y_test)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Machine learning models"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will use 4 different machine learning models to predict the binding affinity of a drug/compound to the PI3K protein.  \n",
    "First, we will define the models in a named list.  \n",
    "Using the following parameters:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define machine learning models in a list\n",
    "models = {\n",
    "    'knn_clf': KNeighborsClassifier(n_neighbors = 4, # K parameter\n",
    "                                        weights = 'distance'), # use the inverse of the distance values as weights\n",
    "        \n",
    "    'logistic_regression': LogisticRegression(penalty = \"l2\", # use a penalty for large weights\n",
    "                                                  solver = \"liblinear\", # use a linear solver\n",
    "                                                  max_iter = 200), # number of iterations\n",
    "        \n",
    "    'decision tree': DecisionTreeClassifier(criterion = 'gini'), # impurity criterion\n",
    "    \n",
    "    'random_forest': RandomForestClassifier(bootstrap = True, # bootstrapping\n",
    "                                                criterion = 'gini', # impurity criterion\n",
    "                                                max_features = int(np.sqrt(X_train.shape[1])), # number of features at each split\n",
    "                                                n_estimators = 300) # number of trees\n",
    "}\n",
    "   "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Evaluation metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Evaluation metrics:\n",
    "    \n",
    "> Confusion matrix : Count matrix of predicted vs true labels.  \n",
    "TP : Predicted positive & label positive.  \n",
    "FP : Predicted positive & label negative.  \n",
    "FN : Predicted negative & label positive.  \n",
    "TN : Predicted negative & label negative.  \n",
    "Accuracy : (TP + TN)/All  \n",
    "Precision : TP/(TP + FP)  \n",
    "Recall : TP/(TP + FN)  \n",
    "\n",
    "The following metrics will be calculated by the calculate_metrics function.  \n",
    "https://en.wikipedia.org/wiki/Confusion_matrix  \n",
    "In the binding affinity prediction problem, the most important metric is precision."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_metrics(y_true, y_pred, plots=False):\n",
    "    assert isinstance(y_true, np.ndarray), 'y_true should be np.array'\n",
    "    assert len(y_true.shape) == len(y_pred.shape) == 1, 'y_true or y_pred shapes are not 1 (probably not squeezed)'\n",
    "    y_pred_bin = y_pred > 0.5\n",
    "\n",
    "    cf = confusion_matrix(y_true, y_pred_bin)\n",
    "    tn, fp, fn, tp = cf.ravel()\n",
    "\n",
    "    metrics = {\n",
    "           'TN': tn,\n",
    "           'FP': fp,\n",
    "           'FN': fn,\n",
    "           'TP': tp,\n",
    "           'precision': precision_score(y_true, y_pred_bin),\n",
    "           'recall': recall_score(y_true, y_pred_bin),\n",
    "           'accuracy': accuracy_score(y_true, y_pred_bin),\n",
    "          }\n",
    "    return(metrics)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Train the models and make predictions for the test set"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, we will train the models in a loop and evaluate their performance in the test set."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Fit models and calculate evaluation metrics  \n",
    "metrics = {} # initialize empty\n",
    "for name, model in models.items(): # loop for all models\n",
    "    model.fit(X_train, y_train) # train the model\n",
    "    y_pred = model.predict(X_test) # predict on the test set\n",
    "    y_true = y_test.squeeze() # squeeze values in one dimension\n",
    "    metrics[name] = calculate_metrics(np.array(y_true), y_pred.squeeze()) # call the metrics function"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Test set performance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>TN</th>\n",
       "      <th>FP</th>\n",
       "      <th>FN</th>\n",
       "      <th>TP</th>\n",
       "      <th>precision</th>\n",
       "      <th>recall</th>\n",
       "      <th>accuracy</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>knn_clf</th>\n",
       "      <td>406.0</td>\n",
       "      <td>72.0</td>\n",
       "      <td>64.0</td>\n",
       "      <td>209.0</td>\n",
       "      <td>0.743772</td>\n",
       "      <td>0.765568</td>\n",
       "      <td>0.818908</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>logistic_regression</th>\n",
       "      <td>410.0</td>\n",
       "      <td>68.0</td>\n",
       "      <td>58.0</td>\n",
       "      <td>215.0</td>\n",
       "      <td>0.759717</td>\n",
       "      <td>0.787546</td>\n",
       "      <td>0.832224</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>decision tree</th>\n",
       "      <td>403.0</td>\n",
       "      <td>75.0</td>\n",
       "      <td>67.0</td>\n",
       "      <td>206.0</td>\n",
       "      <td>0.733096</td>\n",
       "      <td>0.754579</td>\n",
       "      <td>0.810919</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>random_forest</th>\n",
       "      <td>425.0</td>\n",
       "      <td>53.0</td>\n",
       "      <td>71.0</td>\n",
       "      <td>202.0</td>\n",
       "      <td>0.792157</td>\n",
       "      <td>0.739927</td>\n",
       "      <td>0.834887</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                        TN    FP    FN     TP  precision    recall  accuracy\n",
       "knn_clf              406.0  72.0  64.0  209.0   0.743772  0.765568  0.818908\n",
       "logistic_regression  410.0  68.0  58.0  215.0   0.759717  0.787546  0.832224\n",
       "decision tree        403.0  75.0  67.0  206.0   0.733096  0.754579  0.810919\n",
       "random_forest        425.0  53.0  71.0  202.0   0.792157  0.739927  0.834887"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pd.DataFrame(metrics).T"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Use a trained model to make new predictions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0,\n",
       "       1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1,\n",
       "       0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0,\n",
       "       0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1,\n",
       "       0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1,\n",
       "       0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1,\n",
       "       0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0,\n",
       "       0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0,\n",
       "       0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0,\n",
       "       1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1,\n",
       "       0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,\n",
       "       0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0,\n",
       "       0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1,\n",
       "       1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0,\n",
       "       1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1,\n",
       "       0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1,\n",
       "       1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0,\n",
       "       1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n",
       "       1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1,\n",
       "       0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0,\n",
       "       0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,\n",
       "       0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1,\n",
       "       0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1,\n",
       "       0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1,\n",
       "       0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n",
       "       1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0,\n",
       "       1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0,\n",
       "       0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0,\n",
       "       1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0,\n",
       "       0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1,\n",
       "       0, 1, 1], dtype=int64)"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "predictions = models['random_forest'].predict(X_test)\n",
    "predictions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 3: Which algorithm has the best performance on the test set?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Based on the initial analysis on Question 1, the most important metric is precision. Therefore, judging by the results of evaluation metrics for the four machine learning models, the model with the highest performance on the test set is **Random Forest**."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 4: Suggest 2 avenues for further investigation in order to improve the test set performance on this task."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In order to improve the test set performance on this task we suggest the two following avenues:  \n",
    "\n",
    "**1st Avenue: Hyperparameter Tuning**   \n",
    "To improve the performance on the test set we can tune the hyperparameters for each model to achieve better precision on the dataset for each algorithm. All we have to do is to create a grid search among possible values that the parameters can take and evaluate the results using the right error or score metric(in this case precision). Although the search takes time, it can improve the results. For instance:  \n",
    ">**KNN algorithm:**  \n",
    "We perform an optimazation, in this case random search, to select the ideal K-parameter, which defines the number for the nearest 'neighbors' that the model has to calculate the distance between the test sample and each 'neighbor', in order to classify the test samples. Therefore, we run the KNN algorithm with different prices for the K-parameter, calculate the test set performance(precision) for each K used and then we identify the price of K that had the best performance on the test set. Otherwise, we can perform other optimization methods sush as genetic algorithms etc.  \n",
    "\n",
    ">**Random Forest:**  \n",
    "In the same direction with the KNN algorithm, we want to identify the ideal number of trees that constitute the Random Forest model, in order to increase the performance(higher precision in this case). Therefore, we perform a random search optimization with different prices for the 'number of trees'-parameter, in order to select the one with the highest performance on the test set. As mentioned in the 1st Avenue for the K-parameter optimization, so here other optimization methods such as genetic algorithms etc. can be used for identifying the ideal number of trees for the model. \n",
    "\n",
    "** Both of the examples above focus on finding the ideal hyperparameters with random search, because there is no global optimum or specific guideline for identifying the parameter that fits ideally in each model. Only in the case of the Random Forest model there is an informal directive that the number of trees in the Random Forest is typically over 500.  \n",
    "\n",
    "**2nd Avenue: Ensemble Learning**  \n",
    "This technique simply combines diverse set of learners (individual models) together to improvise on the stability and predictive power of the model and produce better results. This can be achieved through many ways:\n",
    "1) **Bagging**: Bagging tries to implement similar learners on small sample populations and then takes a mean of all the predictions.  \n",
    "2) **Boosting**: Boosting is an iterative technique which adjusts the weight of an observation based on the last classification. (XGBoost is included in this category)   \n",
    "3) **Stacking**: Stacking is the use of a learner to combine output from different learners.  \n",
    "4) **Blending**: Blending follows the same approach as stacking but uses only a holdout (validation) set from the train set to make predictions. In other words, unlike stacking, the predictions are made on the holdout set only. The holdout set and the predictions are used to build a model which is run on the test set.   \n",
    "5) **Max Voting**: In this technique, multiple models are used to make predictions for each data point. The predictions by each model are considered as a â€˜voteâ€™. The predictions which we get from the majority of the models are used as the final prediction.  \n",
    "6) **Averaging**: Similar to the max voting technique, multiple predictions are made for each data point in averaging. In this method, we take an average of predictions from all the models and use it to make the final prediction. (Sometimes the averaging can be performed assigning different weights to define the importance of each model for prediction. This technique is called **Weighted Averaging**)  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 5: (Optional) Implement one of your suggestions to improve the performance on the test set."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Implementation of the **1st Avenue** in the KNN algorithm, in order to improve the performance on the test set:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We want to identify the ideal hyperparameter K for the KNN algorithm that has the best performance on the test set. In this case the performance is measured by precision, the higher the precision, the higher the performance of the model on the test set. Consequently, we run the code for different K prices and we conclude that with the K-parameter equal to 559 (which means that the model calculates the distances between the test sample and 559 nearest neighbor samples), the model has the best performance on the test set. Any price for K-parameter above the 559 does not have an impact on performance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define machine learning models in a list\n",
    "models_imp = {\n",
    "              'knn_clf': KNeighborsClassifier(n_neighbors = 559, # K parameter\n",
    "                                        weights = 'distance'), # use the inverse of the distance values as weights\n",
    "              }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Evaluation metrics\n",
    "def calculate_metrics(y_true, y_pred, plots=False):\n",
    "    assert isinstance(y_true, np.ndarray), 'y_true should be np.array'\n",
    "    assert len(y_true.shape) == len(y_pred.shape) == 1, 'y_true or y_pred shapes are not 1 (probably not squeezed)'\n",
    "    y_pred_bin = y_pred > 0.5\n",
    "\n",
    "    cf = confusion_matrix(y_true, y_pred_bin)\n",
    "    tn, fp, fn, tp = cf.ravel()\n",
    "\n",
    "    metrics_imp = {\n",
    "           'TN': tn,\n",
    "           'FP': fp,\n",
    "           'FN': fn,\n",
    "           'TP': tp,\n",
    "           'precision': precision_score(y_true, y_pred_bin),\n",
    "           'recall': recall_score(y_true, y_pred_bin),\n",
    "           'accuracy': accuracy_score(y_true, y_pred_bin),\n",
    "          }\n",
    "    return(metrics_imp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Fit models and calculate evaluation metrics  \n",
    "metrics_imp = {} # initialize empty\n",
    "for name, model in models_imp.items(): # loop for all models\n",
    "    model.fit(X_train, y_train) # train the model\n",
    "    y_pred = model.predict(X_test) # predict on the test set\n",
    "    y_true = y_test.squeeze() # squeeze values in one dimension\n",
    "    metrics_imp[name] = calculate_metrics(np.array(y_true), y_pred.squeeze()) # call the metrics function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>FN</th>\n",
       "      <th>FP</th>\n",
       "      <th>TN</th>\n",
       "      <th>TP</th>\n",
       "      <th>accuracy</th>\n",
       "      <th>precision</th>\n",
       "      <th>recall</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>knn_clf</th>\n",
       "      <td>252.0</td>\n",
       "      <td>0.0</td>\n",
       "      <td>478.0</td>\n",
       "      <td>21.0</td>\n",
       "      <td>0.664447</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.076923</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "            FN   FP     TN    TP  accuracy  precision    recall\n",
       "knn_clf  252.0  0.0  478.0  21.0  0.664447        1.0  0.076923"
      ]
     },
     "execution_count": 82,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Test set performance\n",
    "pd.DataFrame(metrics_imp).T"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Implementation of the **2nd Avenue** using the Max Voting method, in order to improve the performance on the test set:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The Max Voting method is generally used for classification problems. In this case, we are going to use the KNN, Logistic Regression, Decision Tree and Random Forest models to make predictions on the test set and these predictions will be considered as 'votes'. The predictions ('votes') which we get from the majority of the models are used as the final prediction. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 128,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define machine learning models in a list\n",
    "from sklearn.ensemble import VotingClassifier\n",
    "models_vot = {\n",
    "              'knn_clf': KNeighborsClassifier(n_neighbors = 4, # K parameter\n",
    "                                        weights = 'distance'), # use the inverse of the distance values as weights\n",
    "        \n",
    "              'logistic_regression': LogisticRegression(penalty = \"l2\", # use a penalty for large weights\n",
    "                                                  solver = \"liblinear\", # use a linear solver\n",
    "                                                  max_iter = 200), # number of iterations\n",
    "        \n",
    "              'decision tree': DecisionTreeClassifier(criterion = 'gini'), # impurity criterion\n",
    "    \n",
    "              'random_forest': RandomForestClassifier(bootstrap = True, # bootstrapping\n",
    "                                                criterion = 'gini', # impurity criterion\n",
    "                                                max_features = int(np.sqrt(X_train.shape[1])), # number of features at each split\n",
    "                                                n_estimators = 300), # number of trees\n",
    "    \n",
    "              'VotingClf': VotingClassifier(estimators=[('lr', LogisticRegression(penalty = \"l2\", \n",
    "                                                                                 solver = \"liblinear\", max_iter = 200)),\n",
    "                                                        ('dt', DecisionTreeClassifier(criterion = 'gini')), \n",
    "                                                        ('rf', RandomForestClassifier(bootstrap = True, criterion = 'gini',\n",
    "                                                                                 max_features = int(np.sqrt(X_train.shape[1])),\n",
    "                                                                                 n_estimators = 300)),\n",
    "                                                        ('knn', KNeighborsClassifier(n_neighbors = 4, weights = 'distance'))], \n",
    "                                           voting='hard')   \n",
    "             }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 125,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Evaluation metrics\n",
    "def calculate_metrics(y_true, y_pred, plots=False):\n",
    "    assert isinstance(y_true, np.ndarray), 'y_true should be np.array'\n",
    "    assert len(y_true.shape) == len(y_pred.shape) == 1, 'y_true or y_pred shapes are not 1 (probably not squeezed)'\n",
    "    y_pred_bin = y_pred > 0.5\n",
    "\n",
    "    cf = confusion_matrix(y_true, y_pred_bin)\n",
    "    tn, fp, fn, tp = cf.ravel()\n",
    "\n",
    "    metrics_vot = {\n",
    "           'TN': tn,\n",
    "           'FP': fp,\n",
    "           'FN': fn,\n",
    "           'TP': tp,\n",
    "           'precision': precision_score(y_true, y_pred_bin),\n",
    "           'recall': recall_score(y_true, y_pred_bin),\n",
    "           'accuracy': accuracy_score(y_true, y_pred_bin),\n",
    "          }\n",
    "    return(metrics_vot)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 126,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Fit models and calculate evaluation metrics  \n",
    "metrics_vot = {} # initialize empty\n",
    "for name, model in models_vot.items(): # loop for all models\n",
    "    model.fit(X_train, y_train) # train the model\n",
    "    y_pred = model.predict(X_test) # predict on the test set\n",
    "    y_true = y_test.squeeze() # squeeze values in one dimension\n",
    "    metrics_vot[name] = calculate_metrics(np.array(y_true), y_pred.squeeze()) # call the metrics function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 127,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>TN</th>\n",
       "      <th>FP</th>\n",
       "      <th>FN</th>\n",
       "      <th>TP</th>\n",
       "      <th>precision</th>\n",
       "      <th>recall</th>\n",
       "      <th>accuracy</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>knn_clf</th>\n",
       "      <td>406.0</td>\n",
       "      <td>72.0</td>\n",
       "      <td>64.0</td>\n",
       "      <td>209.0</td>\n",
       "      <td>0.743772</td>\n",
       "      <td>0.765568</td>\n",
       "      <td>0.818908</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>logistic_regression</th>\n",
       "      <td>410.0</td>\n",
       "      <td>68.0</td>\n",
       "      <td>58.0</td>\n",
       "      <td>215.0</td>\n",
       "      <td>0.759717</td>\n",
       "      <td>0.787546</td>\n",
       "      <td>0.832224</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>decision tree</th>\n",
       "      <td>397.0</td>\n",
       "      <td>81.0</td>\n",
       "      <td>68.0</td>\n",
       "      <td>205.0</td>\n",
       "      <td>0.716783</td>\n",
       "      <td>0.750916</td>\n",
       "      <td>0.801598</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>random_forest</th>\n",
       "      <td>429.0</td>\n",
       "      <td>49.0</td>\n",
       "      <td>69.0</td>\n",
       "      <td>204.0</td>\n",
       "      <td>0.806324</td>\n",
       "      <td>0.747253</td>\n",
       "      <td>0.842876</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>VotingClf</th>\n",
       "      <td>435.0</td>\n",
       "      <td>43.0</td>\n",
       "      <td>71.0</td>\n",
       "      <td>202.0</td>\n",
       "      <td>0.824490</td>\n",
       "      <td>0.739927</td>\n",
       "      <td>0.848202</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                        TN    FP    FN     TP  precision    recall  accuracy\n",
       "knn_clf              406.0  72.0  64.0  209.0   0.743772  0.765568  0.818908\n",
       "logistic_regression  410.0  68.0  58.0  215.0   0.759717  0.787546  0.832224\n",
       "decision tree        397.0  81.0  68.0  205.0   0.716783  0.750916  0.801598\n",
       "random_forest        429.0  49.0  69.0  204.0   0.806324  0.747253  0.842876\n",
       "VotingClf            435.0  43.0  71.0  202.0   0.824490  0.739927  0.848202"
      ]
     },
     "execution_count": 127,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Test set performance\n",
    "pd.DataFrame(metrics_vot).T"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
